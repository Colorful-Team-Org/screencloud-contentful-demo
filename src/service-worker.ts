/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */
/* eslint-disable @typescript-eslint/no-use-before-define */
// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import {
  clientsClaim,
  CachedResponseWillBeUsedCallbackParam,
  registerQuotaErrorCallback,
  HandlerDidCompleteCallbackParam,
} from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkOnly, StaleWhileRevalidate } from 'workbox-strategies';
import { WorkboxPlugin } from 'workbox-core';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { setCacheNameDetails } from 'workbox-core';
import { CacheExpiration } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();
// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

self.addEventListener('install', (event: ExtendableEvent) => {
  // Installing a new service worker
  console.log('SW - install', event);
});

self.addEventListener('activate', event => {
  // Activating the new service worker
  console.log('SW - activate', event);

  const clearGoogleFontsStylesheetsCache = async () => {
    await Promise.all([
      await caches.open(mkCacheName('google-fonts-stylesheets')).then(cache => {
        cache.keys().then(async keys => {
          const cacheItemPromises = keys.map(key => cache.delete(key));
          return await Promise.all(cacheItemPromises);
        });
      }),
      await caches.open(mkCacheName('custom-assets')).then(cache => {
        cache.keys().then(async keys => {
          const cacheItemPromises = keys.map(key => cache.delete(key));
          return await Promise.all(cacheItemPromises);
        });
      }),
    ]);
  };
  clearGoogleFontsStylesheetsCache();
});

const daysInSeconds = (numberOfDays: number): number => numberOfDays * 24 * 60 * 60;

const cachePrefix = 'app'; // the app caches use this prefix to be able to remove old caches easier

setCacheNameDetails({
  prefix: cachePrefix,
});

// precache methods honor setCacheNameDetails.prefix but strategies do not
// so we are using this function to set their cache name
const mkCacheName = (name: string): string => `${cachePrefix}-${name}`;

const expirationManager = new CacheExpiration(mkCacheName('images'), {
  maxEntries: 250, //employs LRU
  maxAgeSeconds: daysInSeconds(14),
  matchOptions: {
    ignoreVary: true,
  },
});

let hasQuotaError = false;

// Subscribe to quota error from workbox and log to datadog
registerQuotaErrorCallback(async () => {
  // Check if there is a Quota Error already in progress
  // This could happen when multiple instances are displayed/loading in different zones
  if (!hasQuotaError) {
    hasQuotaError = true;

    const cacheKeys = await self.caches.keys();
    const cacheKeysToDelete = cacheKeys.filter(key => key.includes(`${cachePrefix}-`));

    const cacheMap: { [key: string]: number } = {};

    await Promise.all(
      cacheKeysToDelete.map(async cacheKey => {
        await caches.open(cacheKey).then(cache => {
          cache.keys().then(async keys => {
            cacheMap[cacheKey] = keys.length;
            const cacheItemPromises = keys.map(key => cache.delete(key));
            return await Promise.all(cacheItemPromises);
          });
        });
      })
    );

    hasQuotaError = false;
  }
});

class CachePlugin implements WorkboxPlugin {
  // Update the timestampe on the item that was accessed so that it will extend its life in the cache
  cachedResponseWillBeUsed(
    param: CachedResponseWillBeUsedCallbackParam
  ): Promise<Response | void | null | undefined> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async resolve => {
      await expirationManager.updateTimestamp(param.request.url);
      resolve(param.cachedResponse);
    });
  }

  // Remove all items in the cache which have expired if the handler is used that is associated with the cache
  handlerDidComplete(param: HandlerDidCompleteCallbackParam): Promise<void | null | undefined> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async resolve => {
      await expirationManager.expireEntries();
      resolve(undefined);
    });
  }
}

// 1. Page Assets Handler
// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }
    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Image & Imgix Handler
registerRoute(
  ({ url, request }) => {
    return (
      request.destination === 'image' ||
      // match https://<any subdomain>.imgix.net
      url.href.match(/^https:\/\/[-\w]+\.imgix\.net/)
    );
  },
  new CacheFirst({
    // Use a custom cache name.
    cacheName: mkCacheName('images'),
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new CachePlugin(),
    ],
  })
);

// Google Fonts Stylesheet
// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy since stylesheets can change frequently
// Always comes back as an opaque response
registerRoute(
  /^https:\/\/fonts\.googleapis\.com/,
  new StaleWhileRevalidate({
    cacheName: mkCacheName('google-fonts-stylesheets'),
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: daysInSeconds(21),
      }),
    ],
  })
);

// Google Fonts Webfonts
// Seems to always be CORS response due to crossOrigin set on link tag
// Disabled CORS on localhost - font files will show as Opaque responses
// When caching Opaue responses you will see an increase in cache storage different on each browser
// https://developer.chrome.com/docs/devtools/progressive-web-apps/#opaque-responses
registerRoute(
  /^https:\/\/fonts\.gstatic\.com/,
  new StaleWhileRevalidate({
    cacheName: mkCacheName('google-fonts-webfonts'),
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: daysInSeconds(21),
      }),
    ],
  })
);

// Custom stylesheets and fonts for users adding custom fonts which are not hosted by Google
// https://medium.com/dev-channel/service-worker-caching-strategies-based-on-request-types-57411dd7652c
registerRoute(
  ({ request }) => request.destination === 'style' || request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: mkCacheName('custom-assets'),
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200], // Status code 0 is used for opaque responses.
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: daysInSeconds(21),
      }),
    ],
  })
);

// Everything else (except service-worker.js & manifest.json)
registerRoute(({ url }) => {
  return !url.pathname.includes('service-worker.js') && !url.pathname.includes('manifest.json');
}, new NetworkOnly());
